#include<bits/stdc++.h>
using namespace std;

typedef pair<int, int> ii;
struct data {
    int L, R, val;
    data() {}; data(int L, int R, int val) : L(L), R(R), val(val) {};
};

const int N = 1e5 + 4;
int n, Q;
ii a[N];

struct Persistent_Interval_Tree {
    data node[8600010];
    int numNode;

    Persistent_Interval_Tree() { 
        numNode = 0; 
        for (int i = 0; i < 8600010; ++i) node[i] = data(0, 0, 0); 
    }

    void Build(int i, int l, int r) {
        numNode = max(numNode, i);
        if (l == r) {
            node[i] = data(-1, -1, 0);
            return;
        }
        int mid = (l + r) / 2;
        Build(2*i, l, mid); Build(2*i+1, mid+1, r);
        node[i] = data(2*i, 2*i+1, 0);
    }

    int update(int i, int l, int r, int x, int y, int val) {
            assert(!(l > y || x > r));
        if (x <= l && r <= y) {
            node[++numNode] = data(-1, -1, val);
            return numNode;
        }
        int cur = ++numNode, mid = (l + r) / 2;
        if (x <= mid) {
            int tmp = update(node[i].L, l, mid, x, y, val); 
            node[cur] = data(tmp, node[i].R, 0);
        }
        else {
            int tmp = update(node[i].R, mid+1, r, x, y, val);
            node[cur] = data(node[i].L, tmp, 0);
        }
        node[cur].val = node[node[cur].L].val + node[node[cur].R].val;  
        return cur;
    }

    int get(int i, int l, int r, int x, int y) {
        if (l > y || x > r || i == -1) return 0;
        if (x <= l && r <= y) return node[i].val;
        int mid = (l + r) / 2;
        int tmp1 = get(node[i].L, l, mid, x, y);
        int tmp2 = get(node[i].R, mid+1, r, x, y);
        return tmp1 + tmp2;
    }

} IT;

int root[N];

void sol() {
    IT.Build(1, 1, n); 

    sort(a+1, a+n+1); root[0] = 1;
    for (int i = 1; i <= n; ++i) {
        root[i] = IT.update(root[i-1], 1, n, a[i].second, a[i].second, 1);
    }

    int L, R, k;
    while (Q--) {
        cin >> L >> R >> k;
        int l = 1, r = n, ans = -1;
        while (l <= r) {
            int mid = (l + r) / 2;
            int Count = IT.get(root[mid], 1, n, L, R);
            if (Count == k) {
                ans = mid; r = mid - 1;
            }
            else if (Count > k) r = mid - 1;
            else l = mid + 1;
        }
        cout << a[ans].first << '\n';
    }
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    //freopen("input.txt", "r", stdin);
    //freopen("output.txt", "w", stdout);

    cin >> n >> Q;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].first;
        a[i].second = i;
    }

        //assert(n * Q * log2(n) <= 8*N); 
        assert(n < N && Q < 5004);

    sol();

    return 0;
}
